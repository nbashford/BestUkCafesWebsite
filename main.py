"""
REQUIRES - "all_cafes_csv.csv" - cafe data generated by the project:
    CafeDataScraping,
    from: https://github.com/nbashford/CafeDataScraping

Note - the FIRST user to Sign Up is set as the administrator - changes the addition of Add Cafe data.
If user is Administrator - then Add Cafe page adds the new cafe data to the main Cafes Database.
Else - Add Cafe data is added to the NewCafes database instead - so administrator can review before adding.

todo 1:
- add all the global variables for the search filter in a dictionary and
define a function for updating

"""
import collect_new_cafe
from flask import Flask, render_template, redirect, url_for, request, flash, Response, jsonify
from flask_bootstrap import Bootstrap5
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField, SelectField, PasswordField, EmailField
from wtforms.validators import DataRequired, URL, ValidationError, Length
import csv
import datetime
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship
from sqlalchemy import Integer, String, Float, DateTime, Text, func
from sqlalchemy.exc import IntegrityError
from flask_login import UserMixin, login_user, LoginManager, login_required, current_user, logout_user
from werkzeug.security import generate_password_hash, check_password_hash
import os

from db_models import (db, favourites_table, Cafes, Users, Comment, NewCafes, add_data_to_database,
                       get_days_closed_string)
from refine_search_helper import SearchFilterValues

# GLOBAL VARIABLES
first_form_submitted = False  # for user add cafe page - flag to check which form to load
page_limit = 20  # display all cafes webpage limit


# ----------- APP Setup ----------------------------------------------------------

app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('APP_SECRET_KEY')  # pass app secret key
app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv("DATABASE_URI")  # pass database uri

Bootstrap5(app)  # initialise bootstrap flask app
login_manager = LoginManager(app)  # initialise login manager with app


# Set Up Flask Login Manager
@login_manager.user_loader
def load_user(user_id):
    return db.session.get(Users, int(user_id))


# initialise db with flask app
db.init_app(app)

# SET UP ALL DATABASE TABLES - database tables defined in db_models.py
with app.app_context():
    db.create_all()
    try:
        # data initially added to database
        add_data_to_database()
    except IntegrityError:
        # data has already been added - no action
        print("CSV data already loaded")


# initialise the SearchFilterValues class as helper to refine search form
filter_search = SearchFilterValues()


# ------------------------ FLASK FORMS ------------------------------------------------

class CafeForm(FlaskForm):
    """First flask form for adding new cafe added (page 1)"""
    name = StringField('Cafe name', validators=[DataRequired()])
    street = StringField('Street address', validators=[DataRequired()])
    city = StringField('City/Town', validators=[DataRequired()])
    postcode = StringField('Postcode', validators=[DataRequired()])
    submit = SubmitField('Submit', render_kw={'class': 'btn btn-warning btn-lg w-100 mt-3'})


class CafeAdditionalInfo(FlaskForm):
    """Second flask form for adding new cafe data (page 2)"""
    # create the opening times options (06:00 - 21:00)
    times = [
        (f"{hour}:{str(minutes).zfill(2)}")  # , {hour}:{str(minutes).zfill(2)}
        for hour in range(6, 21)
        for minutes in range(0, 60, 15)
    ]
    times.insert(0, ("Closed"))  # add option for closed
    times.insert(0, ("select"))  # add placeholder

    # Define day opening times select fields
    monday_morn = SelectField(choices=times)
    monday_eve = SelectField(choices=times)
    tuesday_morn = SelectField(choices=times)
    tuesday_eve = SelectField(choices=times)
    wednesday_morn = SelectField(choices=times)
    wednesday_eve = SelectField(choices=times)
    thursday_morn = SelectField(choices=times)
    thursday_eve = SelectField(choices=times)
    friday_morn = SelectField(choices=times)
    friday_eve = SelectField(choices=times)
    saturday_morn = SelectField(choices=times)
    saturday_eve = SelectField(choices=times)
    sunday_morn = SelectField(choices=times)
    sunday_eve = SelectField(choices=times)

    # define wifi, pet and laptop friendly select fields
    wifi = SelectField("Free Wifi?", choices=[(None, "Unknown"), ("Free Wi-Fi", "Yes"), (None, "No")])
    laptop = SelectField("Laptop friendly", choices=[(None, "Unknown"), ("Laptop Friendly", "Yes"), (None, "No")])
    pets = SelectField("Laptop friendly", choices=[(None, "Unknown"), ("Pet Friendly", "Yes"), (None, "No")])

    submit = SubmitField('Submit')
    cancel = SubmitField('Cancel')


def check_valid_city(form, field):
    """Validator function for SearchForm - checks if there are any saved cafe data for user searched location"""
    if field.data != "":  # if user has added data
        city_count = db.session.query(func.count(Cafes.id)).filter(Cafes.city == field.data).scalar()
        if not city_count:  # if 0 - show error
            raise ValidationError("No data for city - try again")


class SearchForm(FlaskForm):
    """flask form for homepage user search. Containing string field and a select field.
    Select field initialised with all cafe city locations."""
    location = StringField("Town/City",
                           validators=[check_valid_city],
                           render_kw={"placeholder": "Any"})
    location_select = SelectField("Listed locations")
    submit = SubmitField('Search')

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.location_select.choices = get_cities()


class RefineSearch(FlaskForm):
    """
    Flask form for refining the selection of cafes returned.
    Option to filter by name, location, Wi-Fi, pet friendly, laptop friendly and day open.
    Uses an external class object: filter_search (of class SearchFilterValues) - which holds the current
    user selected refined search options - to update this forms selectfield placeholder displayed option.
    """
    cafe_name = SelectField("Select Cafe")
    city_location = SelectField("Select City")
    has_wifi = SelectField("Need Wifi",
                           choices=[("All", "All"), ("Yes", "Yes")])
    need_laptop = SelectField("Laptop suitable",
                           choices=[("All", "All"), ("Yes", "Yes")])
    need_pets = SelectField("Pets allowed",
                           choices=[("All", "All"), ("Yes", "Yes")])
    day_open = SelectField("Day Open",
                           choices=[("Select", "Select"),
                                    ("Every Day", "Every Day"),
                                    ("Monday", "Monday"),
                                    ("Tuesday", "Tuesday"),
                                    ("Wednesday", "Wednesday"),
                                    ("Thursday", "Thursday"),
                                    ("Friday", "Friday"),
                                    ("Saturday", "Saturday"),
                                    ("Sunday", "Sunday")])

    submit_one = SubmitField("Apply Filters")
    clear_filters = SubmitField("Clear Filters")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # gets all cafe names and city locations
        self.city_location.choices = get_cities()
        self.cafe_name.choices = get_cafe_name()

    def update_all_select_fields(self):
        """
        Update all form select fields
        - uses filter_search object values of Search_filter_values class
          to display option from selectfield choice
        """
        self.update_default_city()
        self.update_default_name()
        self.update_default_wifi()
        self.update_default_pets()
        self.update_default_laptop()
        self.update_default_open_day()

    def update_default_name(self):
        """update name select field with current chosen name"""
        self.cafe_name.default = filter_search.name_label
        self.process()

    def update_default_city(self):
        """update city select field with current chosen city"""
        self.city_location.default = filter_search.city_label
        self.process()

    def update_default_wifi(self):
        """update wifi select field with current chosen wifi"""
        self.has_wifi.default = filter_search.wifi_label
        self.process()

    def update_default_pets(self):
        """update pets select field with current chosen pets"""
        self.need_pets.default = filter_search.pets_label
        self.process()

    def update_default_laptop(self):
        """update laptop select field with current chosen laptop"""
        self.need_laptop.default = filter_search.laptop_label
        self.process()

    def update_default_open_day(self):
        """update open day select field with current chosen open day"""
        self.day_open.default = filter_search.open_day_label
        self.process()


class PageSearch(FlaskForm):
    """
    Select page number form for 'All Cafes' page. Cafes displayed are limited to 20 rows of data.
    This form provides a select field that lets users selects 1 of x number of pages to display.
    """
    page_select = SelectField("Page")
    submit = SubmitField("Show Page")

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # update the no. of pages available
        self.page_select.choices = get_page_numbers()

    def update_page_numbers(self, favourites=False):
        """updates the page numbers if the user has refined search"""
        self.page_select.choices = get_page_numbers(favourites=favourites)


class SignUp(FlaskForm):
    """Flask form for signup functionality"""
    name = StringField("Name", validators=[DataRequired(), Length(min=2, max=50)])
    password = PasswordField("Password", validators=[DataRequired(), Length(min=8)])
    email = EmailField("Email", validators=[DataRequired(), Length(min=8)])
    submit = SubmitField("Sign Up")


class LoginForm(FlaskForm):
    """Flask form for logging in"""
    password = PasswordField("Password", validators=[DataRequired(), Length(min=8)], render_kw={"placeholder": "password"})
    email = EmailField("Email", validators=[DataRequired(), Length(min=8)])
    submit = SubmitField("Login")


# ------------------ Helper functions -------------------------------------

def get_page_numbers(favourites=False):
    """calculates the number of pages of resulting refined search 'all cafes' that the user can select from.
    Since in 'All Cafes' and 'Favourites' webpage - a maximum of 20 rows are displayed per page.
    Passes the initial query to filter_query function to filter the db query with the users selected refine search
    options.
    :return: pages - a list of tuples, of page-number and string page-number
    """
    row_count = None
    if favourites:  # if favourites webpage loaded - count no. of cafes added to favourites table
        if current_user.is_authenticated:
            row_count = len(current_user.favourites)

    else:  # get the length of the resulting query after filtering
        query = db.session.query(func.count(Cafes.id))
        query = filter_query(query)  # pass to filter_query
        row_count = query.scalar()

    pages = [(0, 0)]  # default return value if resulting count < 20 (page display limit)
    if row_count:
        page_numbers, remainder = divmod(row_count, page_limit)
        if remainder != 0:  # adjust page numbers if remainder (needs another page to display)
            page_numbers = page_numbers + 1

        if page_numbers >= 1: # if more than 1 page
            pages = [(page, str(page)) for page in range(page_numbers)]  # create tuples list for SelectField

    return pages


def get_cities():
    """
    retrieve all unique city locations from Cafes db table, sorted, and returned as list of tuples for
    Flask form SelectField values
    """
    all_cities = db.session.execute(db.select(Cafes.city).order_by(Cafes.city).distinct()).scalars().all()
    cities = [(city, city) for city in all_cities]
    cities.insert(0, ("Any", "Any"))  # add initial default value
    return cities

def get_cafe_name():
    """
    retrieve all unique cafe names from Cafes db table, sorted, and returned as list of tuples for
    Flask form SelectField values
    """
    all_names = db.session.execute(db.select(Cafes.name).order_by(Cafes.name)).scalars().all()
    names = [(name, name) for name in all_names]
    names.insert(0, ("Any", "Any"))  # add initial default value
    return names


def filter_query(query):
    """
    Filters the passed db query with all user refine search form selectfield options.
    User refine search selectfield options are stored in the filter_search object)
    """
    if filter_search.name:
        query = query.filter(Cafes.name == filter_search.name)
    if filter_search.city:
        query = query.filter(Cafes.city == filter_search.city)
    if filter_search.wifi:
        query = query.filter(Cafes.wifi == filter_search.wifi)
    if filter_search.pets:
        query = query.filter(Cafes.pets == filter_search.pets)
    if filter_search.laptop:
        query = query.filter(Cafes.laptop == filter_search.laptop)
    if filter_search.open_day:
        if filter_search.open_day == "Every Day":
            query = query.filter(Cafes.closed.contains("None"))
        else:
            query = query.filter(~Cafes.closed.contains(filter_search.open_day_label))

    return query


def get_all_cafes(offset_num, favourites=False):
    """Retrieves all cafes - and filters based on the users refined search selectfields -
    only retrieves the 20 records (Page limit) of the user selected page.
    :param: offset_num = page_number * page_limit
        only gets results from page selected
    :param: favourites: flag if getting all cafes added to users favourites table"""

    if favourites and current_user.is_authenticated:
        query = (db.select(Cafes).join(Users.favourites).filter(Users.id == current_user.id)
                 .order_by(Cafes.name)
                 .offset(offset_num)
                 .limit(page_limit))

    else:  # 'All Cafes' webpage
        query = (db.select(Cafes).order_by(Cafes.name)
                 .offset(offset_num)
                 .limit(page_limit))

    # filter the query
    query = filter_query(query)

    # return the list of Cafes
    all_cafes = db.session.execute(query).scalars().all()
    return all_cafes


def add_favourite(user_id, cafe_id):
    """Adds or removes a cafe entry to the users favourites db table.
    Adds if not in favourites, removes of present. """
    user = db.get_or_404(Users, user_id)
    cafe = db.get_or_404(Cafes, cafe_id)

    if user and cafe:
        if cafe not in user.favourites:  # add to favourites
            user.favourites.append(cafe)
            db.session.commit()
            print("Cafe added to favorites!")
        else:  # remove from favourites
            user.favourites.remove(cafe)
            db.session.commit()
            print("Cafe removed from favorites!")


# -----------------------Flask App Routing Functions ------------------------

@app.route("/", methods=['GET', 'POST'])
def home():
    """
    Homepage.
    Passes search form to homepage to allow users to search for cafes by town, or from location selectfield.
    Valid form submission will pass the search query to the 'All cafes' page with the refine search query set.
    """

    filter_search.reset_all()  # reset all previous user refine search form values

    form = SearchForm()
    # If the form is submitted and validation fails
    if form.is_submitted():
        if not form.validate():
            print("Errors")
            if form.location.errors:  # errors in the `location` field
                # set the input field placeholder as the error
                form.location.render_kw["placeholder"] = form.location.errors[0]

        else:
            print("No Errors")
            # remove any previous input and set to default
            form.location.render_kw["placeholder"] = "Any"

    # if the city location passed is valid
    if form.validate_on_submit():
        # if entered into the string input field
        if form.location.data:
            city_location = form.location.data
            city_location = city_location.title()
            # pass input string to 'All Cafes' website
            return redirect(url_for("cafes", data=city_location))

        # if selected cafe location by SelectField
        elif form.location_select.data != "Any":
            city_location = form.location_select.data
            # pass SelectField choice to 'All Cafes' website
            return redirect(url_for("cafes", data=city_location))

        # user not selected but SelectField set to 'Any'
        if not form.location.data and form.location_select.data == "Any":
            # show 'All Cafes'
            return redirect(url_for("cafes"))

    form.location.data = ""
    return render_template("index.html", form=form)


@app.route('/add', methods=["GET", "POST"])
@login_required
def add_cafe():
    """
    Collects User input for adding new cafe to database.
    Passes the first CafeForm when first entered. If valid - then collects data then
    passes the second CafeAdditionalInfo form to collect additional data.
    collected data is then passed as a new record to the NewCafe db.
    """
    global first_form_submitted # remove this !!!!!
    # print(first_form_submitted)

    # first form to still complete
    if not first_form_submitted:
        form = CafeForm()
        if form.validate_on_submit():
            # collect and store first form data
            collect_new_cafe.collecting_cafe_data(form)
            first_form_submitted = True  # set flag
            return redirect(url_for('add_cafe'))

    # First form Completed - second form to complete
    if first_form_submitted:
        form = CafeAdditionalInfo()
        if form.validate_on_submit():
            if form.submit.data:  # if pressed the submit button - Not Cancel
                # print(form.data)
                # collect and store first form data
                collect_new_cafe.collecting_cafe_data(form)
                first_form_submitted = False  # reset flag

                # format the user form cafe data suitable for NewCafe db table
                formatted_cafe = collect_new_cafe.format_details()

                # if administrator
                if current_user.is_authenticated and current_user.id == 1:
                    cafe_class = Cafes  # add to main database
                else:
                    cafe_class = NewCafes  # add to review database

                # if cafe not previously added - add to db
                existing_cafe = db.session.query(cafe_class).filter_by(name=formatted_cafe['name']).first()
                if not existing_cafe:
                    cafe_entry = cafe_class(
                        name=formatted_cafe['name'],
                        link=formatted_cafe.get('link'),
                        city=formatted_cafe['city'],
                        street=formatted_cafe['street'],
                        opening=formatted_cafe['opening'],
                        closed=get_days_closed_string(formatted_cafe['opening']),  # format days closed string
                        postcode=formatted_cafe['postcode'],
                        url_location=formatted_cafe.get('url_location'),
                        wifi=formatted_cafe['wifi'],
                        laptop=formatted_cafe['laptop'],
                        pets=formatted_cafe['pets'],
                        latitude=formatted_cafe['latitude'],
                        longitude=formatted_cafe['longitude'],
                    )
                    db.session.add(cafe_entry)
                    db.session.commit()
                    flash("Thankyou - Your Cafe will be reviewed shortly")

                else:
                    flash("Cafe previously added and reviewed shortly.")

                collect_new_cafe.clear_new_cafe_saved_details()  # reset any held add cafe data
                return redirect(url_for('add_cafe'))

            elif form.cancel.data:
                # reset form flag and form data dictionary
                first_form_submitted = False
                collect_new_cafe.clear_new_cafe_saved_details()
                return redirect(url_for('add_cafe'))

            else:
                first_form_submitted = False
                collect_new_cafe.clear_new_cafe_saved_details()

    return render_template('add.html', form=form) #, form_flag=first_form_submitted)


@app.route('/cafes', methods=['GET', 'POST'])
def cafes():
    """
    Displays All cafes based on the Users selected Refine Search SelectField options.
    If no selectField options - displays all Cafes.
    Allows users to add cafes to favourites if logged in.
    Any refine search SelectField options are stored in the filter_search object of class Search_filter_values,
    to maintain state.
    Entries:
    - from homepage with passed 'City' location
    - NavBar 'All Cafes' - displays all cafes
    - 'Apply filters' button - gets user selectfield refine search and applies
    - 'cancal filters' - clears all filters and shows all cafes
    - from adding cafes to Favourites - reloads with same refine search state
    - from changing page of displayed cafes - displays relevant 20 cafes
    """
    if request.method == "GET":  # reset user filter search select options
        filter_search.reset_all()

    page_num = 0
    form = RefineSearch()  # filtering search form
    page_number_form = PageSearch()  # select page form
    if form.validate_on_submit():

        if form.submit_one.data:  # if 'apply filters' selected
            # update filter_search city data
            filter_search.update_city(location=form.city_location.data) \
                if form.city_location.data != "Any" else filter_search.update_city()
            # update filter_search name data
            filter_search.update_name(name=form.cafe_name.data) \
                if form.cafe_name.data != "Any" else filter_search.update_name()
            # update filter_search wifi data
            filter_search.update_wifi() if form.has_wifi.data == "Yes" \
                else filter_search.update_wifi(reset=True)
            # update filter_search pets data
            filter_search.update_pets() if form.need_pets.data == "Yes" \
                else filter_search.update_pets(reset=True)
            # update filter_search laptop data
            filter_search.update_laptop() if form.need_laptop.data == "Yes" \
                else filter_search.update_laptop(reset=True)
            # update filter_search open day data
            filter_search.update_open_day(day=form.day_open.data) if form.day_open.data != 'Select' \
                else filter_search.update_open_day()

        elif form.clear_filters.data:  # if 'clear filter' clicked
            filter_search.reset_all()

    # if called by user clicking the 'add to favourites' button
    if request.form.get("cafe_id"):
        # obtain the cafe id and add to favourites
        add_favourite(current_user.id, request.form.get("cafe_id"))
        page_num = int(request.form.get('page_num'))  # to reload current page number

    if page_number_form.validate_on_submit():  # if user clicked for other page button
        try:
            # get page number selected
            page_num = int(page_number_form.page_select.data)
        except TypeError:
            page_num = 0

    # 'data' passed from homepage when user selects or enters a cafe location
    if request.args.get('data'):  # city_location
        filter_search.update_city(location=request.args.get('data'))
        form.update_default_city()  # update city refine search

    form.update_all_select_fields()  # updates all refine search SelectFields with any previously selected option
    page_number_form.update_page_numbers()  # updates page number options based on refine search options

    offset_number = page_num * page_limit
    all_cafes = get_all_cafes(offset_number)  # get all cafes respective to the page number user selected

    # get favourite cafe id's
    if current_user.is_authenticated:
        favourite_cafes_ids = [f.id for f in current_user.favourites]
    else:
        favourite_cafes_ids = []

    return render_template('cafes.html', cafes=all_cafes,
                           form=form, form_page=page_number_form, favourite_cafe_ids=favourite_cafes_ids,
                           page_num=page_num)


@app.route('/signup', methods=['GET', 'POST'])
def signup():
    """
    Allows users to sign up.
    Checks if user not previously signed up before adding user to db, otherwise - redirects to Login.
    """
    form = SignUp()
    if form.validate_on_submit():
        # check if previous user
        prev_user = db.session.execute(db.select(Users)
                                       .where(Users.email == form.email.data)).scalar()
        if prev_user:
            flash("User Already Exists - please Login")
            return redirect(url_for('login'))  # redirect with error message

        # no previous user
        name = form.name.data
        email = form.email.data
        password = form.password.data
        # add user to db - hash value of password stored
        new_user = Users(name=name,
                         email=email,
                         pswd=generate_password_hash(password,
                                                     method="pbkdf2:sha256",
                                                     salt_length=8))
        db.session.add(new_user)
        db.session.commit()
        login_user(new_user)  # login with flask manager
        return redirect(url_for('home'))

    return render_template('sign_up.html', form=form)


@app.route('/login', methods=['GET', 'POST'])
def login():
    """
    Logs in user.
    Checks if user previously signed up - if not redirects to sign up.
    """
    form = LoginForm()
    if form.validate_on_submit():
        prev_user = db.session.execute(db.select(Users)
                                       .where(Users.email == form.email.data)).scalar()

        # user not signed up
        if not prev_user:  # redirect to signup with errors
            flash("No User Exists")
            flash("Please Sign Up")
            return redirect(url_for('signup'))

        # check if hash of password matches saved hash
        password = form.password.data
        if check_password_hash(prev_user.pswd, password):
            login_user(prev_user)  # login user
            return redirect(url_for('home'))

        else:  # password incorrect - show warning as placeholder text
            form.password.render_kw["placeholder"] = "Password Incorrect"
            form.password.data = ""

    return render_template("login.html", form=form)


@app.route('/logout')
@login_required
def logout():
    """Logout user"""
    logout_user()
    return redirect(url_for('home'))


@app.route('/about')
def about():
    """Load about page"""
    return render_template("about.html")


@app.route('/favourites', methods=['GET', 'POST'])
@login_required
def favourites():
    """
    Similar to 'All Cafes' webpage. Displays the users saved favourite cafes.
    Favourite cafes can be filtered like within 'All Cafes', as
    any refine search SelectField options are stored in the filter_search object of class Search_filter_values.
    """
    if request.method == "GET":  # clear any previous refine search stored options
        filter_search.reset_all()

    page_num = 0
    form = RefineSearch()  # filtering search form
    page_number_form = PageSearch()  # select page form
    if form.validate_on_submit():
        if form.submit_one.data:  # if 'apply filters' button selected
            # update stored city data
            filter_search.update_city(location=form.city_location.data) \
                if form.city_location.data != "Any" else filter_search.update_city()
            # update stored name data
            filter_search.update_name(name=form.cafe_name.data) \
                if form.cafe_name.data != "Any" else filter_search.update_name()
            # update stored wifi data
            filter_search.update_wifi() if form.has_wifi.data == "Yes" \
                else filter_search.update_wifi(reset=True)
            # update stored pets data
            filter_search.update_pets() if form.need_pets.data == "Yes" \
                else filter_search.update_pets(reset=True)
            # update stored laptop data
            filter_search.update_laptop() if form.need_laptop.data == "Yes" \
                else filter_search.update_laptop(reset=True)
            # update stored open day data
            filter_search.update_open_day(day=form.day_open.data) if form.day_open.data != 'Select' \
                else filter_search.update_open_day()

        elif form.clear_filters.data:  # user clicked 'clear filters'
            filter_search.reset_all()

    # if user clicked the 'add / remove from favourites' button
    if request.form.get("cafe_id"):
        add_favourite(current_user.id, request.form.get("cafe_id")) # add or remove
        page_num = int(request.form.get('page_num'))  # maintain current page displayed state

    # if selected other page to display
    if page_number_form.validate_on_submit():
        try:
            # get page number selected
            page_num = int(page_number_form.page_select.data)
        except TypeError:
            page_num = 0

    # update refine search SelectField options with previous and new selected options
    form.update_all_select_fields()
    # get the page numbers based on SelectField options
    page_number_form.update_page_numbers(favourites=True)

    # get all Cafe records based on filters and page number selected
    offset_number = page_num * page_limit
    all_cafes = get_all_cafes(offset_number, favourites=True)

    return render_template('favourites.html', cafes=all_cafes, form=form,
                           form_page=page_number_form, page_num=page_num)


if __name__ == '__main__':
    app.run(debug=True, port=5002)
